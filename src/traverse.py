#!/usr/bin/env python
import sys
import numpy as np

from read import ID, DESC, SNAP, MASS, HOST, DESC_HOST, MAIN_PROG, columns
import read
import halo

def all_progenitors(tree, key='root'):
	"""Finds all ``nodeIndex`` values belonging to a given merger tree

	Arguments:
		tree (list): merger tree generated by :func:`tree_from_data`
		key (str): (default='root') the dictionary key which is to be returned
	Returns:
		generator: can be fed as an argument to the ``list()`` function
	**References:**
		https://stackoverflow.com/a/9807955
	"""
	if key in tree:
		yield tree[key]
	for node in tree:
		if isinstance(tree[node], list):
			for i in tree[node]:
				for j in all_progenitors(i, key):
					yield j

def yaml_from_tree(tree, properties, level=1):
	"""Generates YAML from a merger tree

	Arguments:
		tree (list): merger tree generated by :func:`tree_from_data`
		properties (list): list of properties to be included in each node of the
			YAML tree
		level (int): (default=1) level of indentation, incremented by recursive
			calls
	"""
	tab = "  "
	ind = tab*level
	for h in tree:
		sys.stdout.write("%s- "%(tab*(level-1)))
		print "root: %d"%(h['root'])
		for property in properties:
			print "%s%s: %s"%(ind, columns[property], str(h['properties'][columns[property]]))
		if len(h['children']) > 0:
			print "%schildren:"%(ind)
			yaml_from_tree(h['children'], properties, level=level+1)
		else:
			print "%schildren: None"%(ind)

def full_tree(d):
	"""Generates a Dot diagram for the naive, full tree from data

	This implementation, given data table, will generate **all** merger trees
	included in the data. It is very inefficient and should only be used for
	testing mock data.

	Arguments:
		d (pandas.DataFrame): dataset provided by :func:`src.read.data`
	"""

	for i in d['nodeIndex']:
		desc = d['descendantIndex'][i]

		if desc == -1:
			print "\t%d;\n"%(i)
		else:
			print "\t%d -> %d;\n"%(i, desc)
		print "\t%d [label=\"%d (%d)\"];\n"%(i, i, d['particleNumber'][i])

		haloes_in_snapshot = d.groupby('snapshotNumber')['nodeIndex'].apply(list)
		masses_in_snapshot = d.groupby('snapshotNumber')['particleNumber'].apply(list)

		for i,_ in enumerate(haloes_in_snapshot):
			rank_label = "\tsnap_%03d [label=\"s_%03d (%d)\"];"\
				%(haloes_in_snapshot.index[i], \
					haloes_in_snapshot.index[i], \
					sum(masses_in_snapshot.iloc[i]))
			rank_label += "\t{rank=same; snap_%03d; "%(haloes_in_snapshot.index[i])
			for node in haloes_in_snapshot.iloc[i]:
				rank_label += str(node)+"; "
			print "%s};\n"%rank_label

def dot_from_data(h, d, mah, m0, f=0.01):
	"""Generates Dot merger tree diagram from data

	The function has a built-in error checking, and fails if any of the haloes it
	encounters are not "main" haloes (if their ``hostIndex`` is not
	``nodeIndex``).

	It generates a label for the node it is being given, and then a link and a
	recursive call to each of the progenitors.

	Arguments:
		d (numpy.ndarray): dataset provided by :mod:`src.read` module
		h (numpy.ndarray): halo; node of the tree progenitors of which are being queried
		m0 (int): mass of the final halo
		f (float): (default=0.01) NFW :math:`f` parameter
	"""

	if not halo.is_main(h, d): raise ValueError("Not a host halo!")

	print "\t%d [label=\"%d (%d, %d, %d)\", style=filled, fillcolor=%s];\n"\
		%(h[ID], h[ID], h[MAIN_PROG], h[MASS], h[SNAP], \
		'green' if h[DESC_HOST] == h[DESC] else 'red')

	progs = halo.progenitors(h, d)
	if (len(progs) > 0):
		for prog in progs:
			print "\t%d -> %d;\n"%(prog, h[ID])
			dot_from_data(halo.get(prog, d), d, mah, m0, f)

def yaml_from_data(h, d, level=1, recursive=False):
	"""Generate YAML from data

	Can be run recursively (to generate a tree-like representation for all
	progenitors, provided by :func:`src.halo.progenitors`), or non-recursively, and
	then it only prints one halo and ``nodeIndex`` values of all progenitors.

	Arguments:
		h (int): ``nodeIndex`` queried
		d (numpy.ndarray): DHalo tree data, as provided by :func:`src.read.data`
		level (int): (default=1) used to increase level counter if printed
			recursively
		recursive (bool): (default=False) if ``True``, descends every time a foreign
			key is encountered;  if ``False``, only prints the IDs
	"""

	if not halo.is_main(h, d): raise ValueError("Not a host halo!")

	h = halo.get(h, d)
	tab = "  "
	ind = tab*level

	# HALO
	sys.stdout.write("%s- "%(tab*(level-1)))
	print "halo: %d"%(h[ID])
	print "%ssnap: %d"%(ind, h[SNAP])
	print "%smass: %d"%(ind, h[MASS])
	print "%shost: %s"%(ind, "self" if h[HOST] == h[ID] else str(h[HOST]))

	# DESCENDANTS
	print "%sdesc: %d"%(ind, h[DESC])
	print "%sdesc_host: %d"%(ind, h[DESC_HOST])

	# PROGENITORS
	hh = halo.progenitors(h, d)
	if (len(hh) > 0):
		if recursive:
			print "%sprog:"%(ind)
			for _h in hh:
				yaml_from_data(_h, d, level+1, True)
		else:
			print "%sprog: [%s]"%(ind, ",".join(map(str, hh)))
	else:
		print "%sprog: -1"%(ind)

def tree_from_data(h, d):
	"""Generates merger tree from data

	Recursively calls itself inside the return statement, generating a merger tree
	of the format::
	
		[{
			'root': nodeIndex,
			'children': [{
				'root': ...
			},{
				'root': ...
			},
			...]
		},]

	Arguments:
		h (int): ``nodeIndex`` of the starting halo
		d (numpy.ndarray): dataset provided by :mod:`src.read` module
	Returns:
		list: merger tree, rooted at the starting halo
	"""

	if not halo.is_main(h, d): raise ValueError("Not a main halo")

	h = halo.get(h, d)
	progenitors = halo.progenitors(h, d)

	return [{
		'root': h[ID],
		'children': [] if len(progenitors) == 0 else \
			[tree_from_data(progenitor, d)[0] for progenitor in progenitors],
	},]

def dot_from_tree(tree, d, m0, f=0.01):
	"""Generates Dot diagram from merger tree

	Every node is formatted as follows::

		[nodeIndex | nodeIndex > descendantIndex (if not merging into main)] (isMainProgenitor, particleNumber, snapshotNumber)

	and is colour coded:

	- green: halo mass exceeds fraction :math:`f`
	- red: halo mmass too small, does not count towards the assembly history

	Arguments:
		tree (list): merger tree generated by :func:`tree_from_data`
		d (numpy.ndarray): dataset provided by :mod:`src.read` module
		m0 (int): mass of the final halo
		f (float): (default=0.01) NFW :math:`f` parameter
	"""
	for leaf in tree:
		h = halo.get(leaf['root'], d)
		print "\t%d [label=\"%s (%d, %d, %d)\", style=filled, fillcolor=%s];"%(\
			h[ID], "%d"%(h[ID]) if h[DESC] == h[DESC_HOST] else "%d > %d"%(h[ID], h[DESC]), \
			h[MAIN_PROG], h[MASS], h[SNAP], \
			"green" if h[MASS] > f*m0  else "red")
		if len(leaf['children']) > 0:
			for child in leaf['children']:
				print "\t%d -> %d;"%(child['root'], leaf['root'])
			dot_from_tree(leaf['children'], d, m0, f)

def mah_from_tree(tree, d, m0, f=0.01):
	"""Generates mass assembly history from a merger tree

	This is essentially a slow implementation of a "group-by" agorithm for all
	progenitors - it goes snapshot by snapshot, and sums progenitors by
	progenitor.

	Arguments:
		tree (list): merger tree generated by :func:`tree_from_data`
		d (numpy.ndarray): dataset provided by :mod:`src.read` module
		m0 (int): mass of the final halo
		f (float): (default=0.01) NFW :math:`f` parameter
	Returns:
		numpy.ndarray: 2-D array, in the ``[[snapshot, mass],[...],...]`` format
	"""
	out = open("tmp.txt", 'w')
	mah = []
	for snap in np.unique(d[:,SNAP]):
		m = 0
		out.write("snapshot: %d\n (+"%snap)
		for h in d[np.where(d[:,SNAP] == snap)]:
			if h[MASS] > f*m0:
				m += h[MASS]
				out.write(" %d"%h[MASS])
			else:
				out.write(" /%d/"%h[MASS])
		out.write(") = %d\n\n"%m)
		mah.append([snap, m])
	out.close()
	return np.array(mah)

def dot_from_mah(m, tree, d):
	"""Generates a subgraph with snaphot numbers and progenitors' masses

	Arguments:
		m (numpy.ndarray): mass assembly history generated by :func:`mah_from_tree`
		tree (list): merger tree generated by :func:`tree_from_data`
		d (numpy.ndarray): dataset provided by :mod:`src.read` module
	"""
	print "\t%s;"%(" -> ".join(["snap_%02d"%(s[0]) for s in m]))
	for s in m:
		print "\tsnap_%02d [label=\"snap_%02d, %d\"];"%(s[0], s[0], s[1])
		print "\t{ rank=same; snap_%02d; %s };"%(s[0], "; ".join(\
			map(str,d[np.where(d[:,SNAP] == s[0])][:,ID])))

if __name__ == '__main__':
	d = read.retrieve()
	h = halo.get(int(sys.argv[1]), d)
	m0 = h[MASS]
	f = 0.01

	t = tree_from_data(h, d)
	d = np.array([halo.get(id, d) for id in \
		list(all_progenitors(t[0], 'root'))])
	m = mah_from_tree(t, d, m0, f)

	print "digraph merger_tree { rankdir=BT;"
	dot_from_tree(t, d, m0, f)
	print "\tsubgraph snapshots { rankdir=BT;"
	dot_from_mah(m, t, d)
	print "\t}"
	print "}"

