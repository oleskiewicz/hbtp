#!/usr/bin/env python
import sys
import logging
from logging.config import fileConfig
import numpy as np

from read import ID, DESC, SNAP, MASS, HOST, DESC_HOST, MAIN_PROG, columns
import read
import halo

def all_progenitors(tree, key='root'):
	"""Finds all ``nodeIndex`` values belonging to a given merger tree

	Arguments:
		tree (list): merger tree generated by :func:`tree_from_data`
		key (str): (default='root') the dictionary key which is to be returned
	Returns:
		generator: can be fed as an argument to the ``list()`` function
	**References:**
		https://stackoverflow.com/a/9807955
	"""
	if key in tree:
		yield tree[key]
	for node in tree:
		if isinstance(tree[node], list):
			for i in tree[node]:
				for j in all_progenitors(i, key):
					yield j

def yaml_from_tree(file, tree, properties, level=1):
	"""Generates YAML from a merger tree

	Arguments:
		file (File): YAML output file
		tree (list): merger tree generated by :func:`tree_from_data`
		properties (list): list of properties to be included in each node of the
			YAML tree
		level (int): (default=1) level of indentation, incremented by recursive
			calls
	"""
	tab = "  "
	ind = tab*level
	for h in tree:
		file.write("%s- "%(tab*(level-1)))
		file.write( "root: %d\n"%(h['root']))
		for property in properties:
			file.write("%s%s: %s\n"%(ind, columns[property], \
				str(h['properties'][columns[property]])))
		if len(h['children']) > 0:
			file.write("%schildren:\n"%(ind))
			yaml_from_tree(h['children'], properties, level=level+1)
		else:
			file.write("%schildren: None\n"%(ind))

def full_tree(d):
	"""Generates a Dot diagram for the naive, full tree from data

	This implementation, given data table, will generate **all** merger trees
	included in the data. It is very inefficient and should only be used for
	testing mock data.

	Arguments:
		d (pandas.DataFrame): dataset provided by :func:`src.read.data`
	"""

	for i in d['nodeIndex']:
		desc = d['descendantIndex'][i]

		if desc == -1:
			print "\t%d;\n"%(i)
		else:
			print "\t%d -> %d;\n"%(i, desc)
		print "\t%d [label=\"%d (%d)\"];\n"%(i, i, d['particleNumber'][i])

		haloes_in_snapshot = d.groupby('snapshotNumber')['nodeIndex'].apply(list)
		masses_in_snapshot = d.groupby('snapshotNumber')['particleNumber'].apply(list)

		for i,_ in enumerate(haloes_in_snapshot):
			rank_label = "\tsnap_%03d [label=\"s_%03d (%d)\"];"\
				%(haloes_in_snapshot.index[i], \
					haloes_in_snapshot.index[i], \
					sum(masses_in_snapshot.iloc[i]))
			rank_label += "\t{rank=same; snap_%03d; "%(haloes_in_snapshot.index[i])
			for node in haloes_in_snapshot.iloc[i]:
				rank_label += str(node)+"; "
			print "%s};\n"%rank_label

def dot_from_data(h, d, mah, m0, nfw_f=0.01):
	"""Generates Dot merger tree diagram from data

	The function has a built-in error checking, and fails if any of the haloes it
	encounters are not "main" haloes (if their ``hostIndex`` is not
	``nodeIndex``).

	It generates a label for the node it is being given, and then a link and a
	recursive call to each of the progenitors.

	Arguments:
		d (numpy.ndarray): dataset provided by :mod:`src.read` module
		h (numpy.ndarray): halo; node of the tree progenitors of which are being queried
		m0 (int): mass of the final halo
		nfw_f (float): (default=0.01) NFW :math:`f` parameter
	"""

	if not halo.is_main(h, d): raise ValueError("Not a host halo!")

	print "\t%d [label=\"%d (%d, %d, %d)\", style=filled, fillcolor=%s];\n"\
		%(h[ID], h[ID], h[MAIN_PROG], halo.mass(h, d), h[SNAP], \
		'green' if h[DESC_HOST] == h[DESC] else 'red')

	progs = halo.progenitors(h, d)
	if (len(progs) > 0):
		for prog in progs:
			print "\t%d -> %d;\n"%(prog, h[ID])
			dot_from_data(halo.get(prog, d), d, mah, m0, nfw_f)

def yaml_from_data(h, d, level=1, recursive=False):
	"""Generate YAML from data

	Can be run recursively (to generate a tree-like representation for all
	progenitors, provided by :func:`src.halo.progenitors`), or non-recursively, and
	then it only prints one halo and ``nodeIndex`` values of all progenitors.

	Arguments:
		h (int): ``nodeIndex`` queried
		d (numpy.ndarray): DHalo tree data, as provided by :func:`src.read.data`
		level (int): (default=1) used to increase level counter if printed
			recursively
		recursive (bool): (default=False) if ``True``, descends every time a foreign
			key is encountered;  if ``False``, only prints the IDs
	"""

	if not halo.is_main(h, d): raise ValueError("Not a host halo!")

	h = halo.get(h, d)
	tab = "  "
	ind = tab*level

	# HALO
	sys.stdout.write("%s- "%(tab*(level-1)))
	print "halo: %d"%(h[ID])
	print "%ssnap: %d"%(ind, h[SNAP])
	print "%smass: %d"%(ind, halo.mass(h, d))
	print "%shost: %s"%(ind, "self" if h[HOST] == h[ID] else str(h[HOST]))

	# SUBHALOES
	print "%ssub: [%s]"%(ind, ",".join(map(str, halo.subhaloes(h, d))))

	# DESCENDANTS
	print "%sdesc: %d"%(ind, h[DESC])
	print "%sdesc_host: %d"%(ind, h[DESC_HOST])

	# PROGENITORS
	hh = halo.progenitors(h, d)
	if (len(hh) > 0):
		if recursive:
			print "%sprog:"%(ind)
			for _h in hh:
				yaml_from_data(_h, d, level+1, True)
		else:
			print "%sprog: [%s]"%(ind, ",".join(map(str, hh)))
	else:
		print "%sprog: -1"%(ind)

def tree_from_data(log, h, d):
	"""Generates merger tree from data

	Recursively calls itself inside the return statement, generating a merger tree
	of the format:

	.. code-block: python
	
		[{
			'root': nodeIndex,
			'children': [{
				'root': ...
			},{
				'root': ...
			},
			...]
		},]

	Arguments:
		log (logging.Logger): log handling object
		h (int): ``nodeIndex`` of the starting halo
		d (numpy.ndarray): dataset provided by :mod:`src.read` module
	Returns:
		list: merger tree, rooted at the starting halo
	"""

	if not halo.is_main(h, d):
		log.error("%d is not a main halo"%halo.get(h, d)[ID])
		raise ValueError()

	h = halo.get(h, d)
	progenitors = halo.progenitors(h, d)
	log.debug("Reached halo %d at snapshot %d"%(h[ID], h[SNAP]))

	return [{
		'root': h[ID],
		'children': [] if len(progenitors) == 0 else \
			[tree_from_data(log, progenitor, d)[0] for progenitor in progenitors],
	},]

def dot_from_tree(file, log, tree, d, m0, nfw_f=0.01):
	"""Generates Dot diagram from merger tree

	Every node is formatted as follows::

		[nodeIndex | nodeIndex > descendantIndex (if not merging into main)] (isMainProgenitor, particleNumber, snapshotNumber)

	and is colour coded:

	- green: halo mass exceeds fraction :math:`f`
	- red: halo mmass too small, does not count towards the assembly history

	Arguments:
		file (File): file with Dot output
		log (logging.Logger): log handling object
		tree (list): merger tree generated by :func:`tree_from_data`
		d (numpy.ndarray): dataset provided by :mod:`src.read` module
		m0 (int): mass of the final halo
		nfw_f (float): (default=0.01) NFW :math:`f` parameter
	"""
	for leaf in tree:
		h = halo.get(leaf['root'], d)
		m = halo.mass(h, d)
		file.write("\t%d [label=\"%s (%d, %d, %d)\", style=filled, fillcolor=%s];\n"%(\
			h[ID], "%d"%(h[ID]) if h[DESC] == h[DESC_HOST] else "%d > %d"%(h[ID], h[DESC]), \
			h[MAIN_PROG], m, h[SNAP], "green" if m > nfw_f*m0  else "red"))
		log.debug("Reached halo %d with %d children"%(leaf['root'], len(leaf['children'])))
		if len(leaf['children']) > 0:
			for child in leaf['children']:
				file.write("\t%d -> %d;\n"%(child['root'], leaf['root']))
			dot_from_tree(file, log, leaf['children'], d, m0, nfw_f)

def mah_from_tree(log, tree, progs, data, nfw_f=0.01):
	"""Generates mass assembly history from a merger tree

	This is essentially a slow implementation of a "group-by" algorithm for all
	progenitors - it goes snapshot by snapshot, and sums progenitors by
	progenitor.

	Arguments:
		log (logging.Logger): log handling object
		tree (list): merger tree generated by :func:`tree_from_data`
		progs (numpy.ndarray): slice of ``data`` containing only progenitors
		data (numpy.ndarray): dataset provided by :mod:`src.read` module
		m0 (int): mass of the final halo
		nfw_f (float): (default=0.01) NFW :math:`f` parameter
	Returns:
		numpy.ndarray: 2-D array, in the ``[[snapshot, mass],[...],...]`` format
	"""
	mah = []
	root = halo.get(tree[0]['root'], data)
	m0 = halo.mass(root, data)

	for snap in np.unique(progs[:,SNAP]):
		sum_m = 0
		for h in progs[np.where(progs[:,SNAP] == snap)]:
			m = halo.mass(h, data)
			if m > nfw_f*m0:
				sum_m += m
		mah.append([root[ID], snap, sum_m])
	return np.array(mah)

def tsv_from_mah(file, mah):
	for row in mah:
		file.write("%d\t%02d\t%d\n"%(row[0], row[1], row[2]))

def dot_from_mah(file, m, tree, progs):
	"""Generates a subgraph with snaphot numbers and progenitors' masses

	Arguments:
		file (File): file with Dot output
		m (numpy.ndarray): mass assembly history generated by :func:`mah_from_tree`
		tree (list): merger tree generated by :func:`tree_from_data`
		progs (numpy.ndarray): slice of ``data`` containing only progenitors
	"""
	file.write("\t%s;"%(" -> ".join(["snap_%02d\n"%(s[1]) for s in m])))
	for s in m:
		file.write("\tsnap_%02d [label=\"(%d, %02d)\"];\n"%(s[1], s[2], s[1]))
		file.write("\t{ rank=same; snap_%02d; %s };"%(s[1], "; \n".join(\
			map(str,progs[np.where(progs[:,SNAP] == s[1])][:,ID]))))

if __name__ == '__main__':
	fileConfig("./logging.conf")
	log = logging.getLogger()

	root = int(sys.argv[1])
	d = read.retrieve()
	nfw_f = 0.01
	h = halo.get(root, d)
	m0 = halo.mass(h, d)

	log.info("Tree for halo %d of mass %d at snapshot %d"%(h[ID], m0, h[SNAP]))

	t = tree_from_data(log, h, d)
	p = np.array([halo.get(id, d) for id in \
		list(all_progenitors(t[0], 'root'))])
	m = mah_from_tree(log, t, p, d, nfw_f)

	with open("./output/mah.tsv", 'a') as file_tsv:
		tsv_from_mah(file_tsv, m)

	with open("./output/mah_%d.dot"%(root), 'w') as file_dot:
		file_dot.write("digraph merger_tree { rankdir=BT;\n")
		dot_from_tree(file_dot, log, t, d, m0, nfw_f)
		file_dot.write("\tsubgraph snapshots {\n")
		dot_from_mah(file_dot, m, t, p)
		file_dot.write("\t}\n")
		file_dot.write("}\n")

