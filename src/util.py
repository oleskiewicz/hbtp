#!/usr/bin/env python3
import multiprocessing as mp

import numpy as np
import pandas as pd


def flatten(tree):
    """Finds all ``nodeIndex`` values belonging to a given merger tree

    Arguments:
        tree (list): merger tree generated by :func:`build`
    Returns:
        generator: to be fed as an argument to the ``list()`` function
    References:
        https://stackoverflow.com/a/2158532
    """
    for node in tree:
        try:
            for subnode in flatten(node):
                yield subnode
        except:
            yield node


def normalise(d, which=-1):
    if type(d) == pd.core.frame.DataFrame:
        d = d.apply(lambda x: x / x[which], 1)
    elif type(d) == np.ndarray:
        d = np.divide(d.T, d.T[which, :]).T
    else:
        raise TypeError("Supply DataFrame or NumPy array")
    return np.array(d)


def stack(d):
    return np.divide(np.sum(d, axis=0), d.shape[0])


def bin(d, by, bins, transform=None):
    vs = transform(d[by]) if transform is not None else d[by]
    return np.digitize(vs, bins)


def count_grouped(d):
    d = np.sort(d)
    dif = np.concatenate(([1], np.diff(d)))
    idx = np.concatenate((np.where(dif)[0], [d.shape[0]]))
    grouped = np.empty(
        len(idx) - 1, dtype=np.dtype([("value", np.int32), ("count", np.int32)])
    )
    grouped["value"] = d[idx[:-1]]
    grouped["count"] = np.diff(idx)
    return grouped


def pad(ls, value=0.0, on_left=True):
    """Pad a 2D list with values.

    Converts this::

        [[1, 2, 3],
         [2, 3]]

    Into this::

        [[1, 2, 3],
         [0, 2, 3]]

    Note:

        This is serving as a poor replacement for ``pivot`` in ``pandas``, only
        for prototyping.

    :param list ls: list of lists
    :param float value: what to pad with
    :param bool on_left: pad on the left if True, on the Right if False
    """

    maxlen = max([len(l) for l in ls])
    for i, l in enumerate(ls):
        if len(ls[i]) < maxlen:
            if on_left:
                ls[i] = ([value] * (maxlen - len(l))) + l
            else:
                ls[i] = l + ([value] * (maxlen - len(l)))
    return maxlen, ls


def pmap(f, xs, nprocs=mp.cpu_count()):
    """Parallel map.

    As seen in: <https://stackoverflow.com/a/16071616>.
    """

    def fun(f, q_in, q_out):
        while True:
            i, x = q_in.get()
            if i is None:
                break
            q_out.put((i, f(x)))

    q_in = mp.Queue(1)
    q_out = mp.Queue()

    proc = [
        mp.Process(target=fun, args=(f, q_in, q_out)) for _ in range(nprocs)
    ]

    for p in proc:
        p.daemon = True
        p.start()

    sent = [q_in.put((i, x)) for i, x in enumerate(xs)]
    [q_in.put((None, None)) for _ in range(nprocs)]
    res = [q_out.get() for _ in range(len(sent))]

    [p.join() for p in proc]

    return [x for i, x in res]
